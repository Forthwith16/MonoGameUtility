Programming Todo
----------------
Try to support instantiation all the way in the base project.
-Some base game objects require instantiation to make copy constructors
--MouseGameObject
--GameObjectLibrary
--GameObjectGroup
-To actually make this work, we may need to require all resources to be loaded from the disk, which is not great

Instantiate should return TSelf, not TSelf?
-This is only the case if we can get it working everywhere





Test if we need to add serializers to all things up the game object hierarchy or if it will be enough for gameobject and the most derived children
-TESTED: RESULT: Slap the basest converter onto every class without their own
--If you don't, you end up with the default print every thing public converter





Colliders should be serializable but collision engines should not be, or at least they shouldn't have their innards serialized, probably
-That said, there's no reason why we can't add a serializer for OctTrees and QuadTrees, since they seem like sensible data structures





Figure out a good way to serialize ShadeGameObjects
-Might be best not to do this and instead only allow 'scene' serialization
--The scene is essentially a single ShadeGameObject which is the parent of everything else, and we deserialize it, allowing us to load everything at once
---This is sensible for batch loading; we do not allow references outside the batch load when doing this
----This is also good b/c it allow us to serialize singleton game objects as well
---Need a translation dictionary, of course, so we can just serialize with whatever IDs we have and then load to new ones





Assets should only serialize in the sense of telling us where to load them from, not their data
-They can have serializers for us to serialize them, but we generally want to load them instead via Content.Load so that we reuse their data
--This implies that assets are immutable





Jump to component doesn't trigger the on entry thing but it does get us there
-Maybe it does, and we're just not active? idk; fix the buttons, and fix everything





Add a Platform property to RenderTargetFriendlyGame via "_services.AddService(typeof(GamePlatform),Platform);" in the base constructor





Add IDs to SpriteRenderer.

Asset Todo
----------
Assets with dependences make their own builds of the dependency
-e.g. a sprite sheet makes its own copy of its reference texture
-WriteSharedResource might solve the problem?

There's an object version of Read; maybe this is where the existing instance comes into play?

SpriteRenderer
-Should have pipeline options for what render settings to assign (we do not serialize them ourselves)
-Readers are out of the pipeline, so we can access GameID, which means we can get our game from just an ID to boot up
-We can pass a game runtime parameter to Content.Load by sending out a file name + a number
--We can also ensure we can make many with the same GameID and also reuse by providing a name + ID
---This will also allow us to create SpriteRenderers through the Content.Load system rather than directly, which lets us grab them from anywhere