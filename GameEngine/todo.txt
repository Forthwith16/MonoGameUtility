Programming Todo
----------------
GameObjects and such, like Animations and such, should not be serializable, but there should be a way to pass them off to an asset constructor to turn them into something we can serialize conveniently
-Instantiate should still be a thing though
-This also makes it clear how level editors work, since we can just modify pure asset data with public get/set power
-This may actually be the way for prefabbing; have game objects keep a reference to their raw initial data (loaded into a static dic like usual) and have that generate a new instance
--If we do this, GET RID OF THE COPY CONSTRUCTORS perhaps, or at least make them all protected




Add an attribute for not serializing public stuff




Give the Sprite assets an asset ID?
-Unclear if this is needed, since we load external assets just fine, and we don't generate spritesheets inside of game objects, for exmaple, so we don't need handles to them beyond the source file
--It would be good to slap it in the interface, however, and be done with it
---It wouldn't hurt to just nab a fresh ID without bothering to store it
-DON'T FORGET TO DEAL WITH DISPOSAL AND FINALIZERS





Each game object should be its own asset file?





We need an attribute system that allows us to get from a generic AffineObject child to its asset class so that we can do asset creation more easily
-The attributes go on the asset class
-If there is no attribute for the type that we are trying to turn into an asset, then we ignore it
-We can create an Attribute class that has a static dictionary of Type -> Constructor that maps a game object type T to its asset version's constructor that takes just the game object of type T as a parameter
--If this constructor doesn't exist, we also ignore it

Add to BaseAsset the Instantiate method





Add support for absolute paths (relative to the content root)
Set Name in ContentItems with its absolute path
Add AssetName to concrete assets

Add AssetName to AssetBase
-Need to preserve the default constructor though, so we should assign the name in the content pipeline when we do so in its content class; the concrete -> asset constructor can just copy/paste the name
-ACTUALLY, maybe we shouldn't do this; maybe it's appropriate for assets not obtained from the content builder to not have names so we can't screw something up
--But then relative paths break, so maybe not...



FromDisc should be set to false at construction time and the Processor or Serializer should set it to true




Move draw calls over to using SpriteRenderer's Matrix2D-based Draw call
-But not when they have position/rot/etc freely available already, which is probably none, b/c parents, but maybe some do




Consider getting rid of Animation entirely and just using Animation2D directly
-This is probably better b/c Animation2D's share resources via their copy constructors
-That said, it does make sense to distinguish between the two so that we can sync animations by using the same one over and over if we want, though this is dangerous b/c duplicate Update calls will likely happen
-Even if we don't get rid of Animation, we should swap to having Animation reuse its frame data, which is immutable, if it's not already
--But no reuse arrays, b/c someone could take advantage of that, which may be a reason to keep Animation





We CAN put Instantiate on resources and game objects if we want, which just converts them into asset form and then creates them again, though this is not ideal b/c slow
-It also kinda hides what's really going on





Assets should retain their asset names, but they should be "" if not loaded from disc until we save them to it





AffineObject serialization should have a flag to skip the transform, since we will often provide it in other forms down the line
-AffineObjects have two child arrays; the proper one has other assets available, is always defined, but may be unpopulated; the other array is a set of internal asset IDs that is only defined on read and is used during LinkAssets to pull other assets into the proper array





Add a ScriptComponent which takes a class with a public default constructor and has some nice base class or interface
-The default serializer just spits out all of the public variables that can be got and set





Try to support instantiation all the way in the base project.
-Some base game objects require instantiation to make copy constructors
--MouseGameObject
--GameObjectLibrary
--GameObjectGroup
-To actually make this work, we may need to require all resources to be loaded from the disk, which is not great

Instantiate should return TSelf, not TSelf?
-This is only the case if we can get it working everywhere





Test if we need to add serializers to all things up the game object hierarchy or if it will be enough for gameobject and the most derived children
-TESTED: RESULT: Slap the basest converter onto every class without their own
--If you don't, you end up with the default print every thing public converter





Colliders should be serializable but collision engines should not be, or at least they shouldn't have their innards serialized, probably
-That said, there's no reason why we can't add a serializer for OctTrees and QuadTrees, since they seem like sensible data structures





Figure out a good way to serialize ShadeGameObjects
-Might be best not to do this and instead only allow 'scene' serialization
--The scene is essentially a single ShadeGameObject which is the parent of everything else, and we deserialize it, allowing us to load everything at once
---This is sensible for batch loading; we do not allow references outside the batch load when doing this
----This is also good b/c it allow us to serialize singleton game objects as well
---Need a translation dictionary, of course, so we can just serialize with whatever IDs we have and then load to new ones





Assets should only serialize in the sense of telling us where to load them from, not their data
-They can have serializers for us to serialize them, but we generally want to load them instead via Content.Load so that we reuse their data
--This implies that assets are immutable





IPrefab can provide a PostBuild method, and you should only serialize things that are IPrefab
-It can provide a Serialize method as well, and perhaps a Deserialize if we can work it